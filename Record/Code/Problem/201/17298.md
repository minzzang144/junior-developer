# 덱(10866)

### 문제

크기가 N인 수열 A = A1, A2, ..., AN이 있다.<br>
수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다.<br>
Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다.<br>
그러한 수가 없는 경우에 오큰수는 -1이다.<br>

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다.<br>
A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.<br>

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.<br>

### 출력

총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.<br>

#### 예제 입력

```
4
3 5 2 7
```

```
4
9 5 4 8
```

#### 예제 출력

```
5 7 7 -1
```

```
-1 8 8 -1
```

### 제출

```
const fs = require('fs');
let input = fs.readFileSync('/dev/stdin').toString().split('\n');
let n = +input.shift();

let stack = input[0].split(' ').map((ele) => Number(ele));
let answer = [];

for(let i = 0; i < n; i++) {
  for(let j = i + 1; j < n + 1; j++) {
    if(stack[i] < stack[j]) {
      answer[i] = stack[j];
      break;
    } else {
      answer[i] = '-1';
    }
    if(stack[j] === 'undefined') {
      answer[i] = '-1';
    }
  }
}

console.log(answer.join(' '));
```

### 모범 답안

```
const input = require("fs").readFileSync("/dev/stdin").toString().trim().split('\n').map(v=>v.split(' ').map(v=>Number(v)))[1];
const stack = [];
let answer = Array(input.length).fill(-1);

for(let i=0; i<input.length;i++){
    while (stack.length&& input[stack[stack.length-1]] < input[i]){
        answer[stack.pop()] = input[i];
    }
    stack.push(i);
}

console.log(answer.join(' '));
```

### 고찰

지금까지 풀었던 문제 중 가장 어렵지 않았나 싶다.<br>
내 답안도 코드샌드박스에서 실행했을 때는 똑같은 결과를 출력했다.<br>
하지만 내 답안은 정답이 될 수 없었다. 시간초과가 출력되기 때문이다.<br>
그 이유는 아마도 내가 스택을 사용해서 풀지 않고 스택을 마치 배열처럼 사용했기 때문에 발생한 결과일 것이다.<br>
배열처럼 사용하면 시간복잡도가 N이 아니라 N제곱이 되는가 보다. for문을 두번 돌려야 했기 때문이다.<br>
다른 사람들의 정답을 봐도 아직 잘 이해가 가지 않는데 계속 진행해보고 나중에 돌아와서 다시 풀어보려 한다.<br>
